#!/bin/bash

# Function to display help message
display_help() {
    echo "Usage: $0 [option...]" >&2
    echo
    echo "   -a                Create a backup"
    echo "   -h                Display this help message and exit"
    echo
    echo "Example (from project root directory on the live server):"
    echo "   vendor/bin/sake-release -a live feature/awesome"
    echo "This creates an sspak file and releases the feature/awesome branch to a live environment"
    echo "Other examples:"
    echo "   vendor/bin/sake-release dev"
    echo "   vendor/bin/sake-release test"
    echo "   vendor/bin/sake-release test my-feature-branch"
    # add more help options here
    exit 1
}

# Check if release is already running
if [ -f "release-running" ]; then
    echo "Going to sleep for 15 minutes as there is already a release running."
    sleep 900
    exit 1
fi

# Set to running
touch release-running
touch release.log

# get data from .env
source ./.env

# Process command line options.
backup=false

# do we need to do a backup
while getopts ":ah" opt; do
    case ${opt} in
    a)
        backup=true
        echo "Backup will be created"
        ;;
    h)
        display_help
        ;;
    \?)
        echo "Invalid Option. Option available is -a (archive / make backup): -$OPTARG" 1>&2
        exit 1
        ;;
    esac
done
shift $((OPTIND - 1))


# Determine git branch based on environment if not provided
branch_name=$2
if [ -z "$2" ]; then
    if [ "$SS_ENVIRONMENT_TYPE" == "live" ]; then
        branch_name="production"
    elif [ "$SS_ENVIRONMENT_TYPE" == "dev" ] || [ "$SS_ENVIRONMENT_TYPE" == "test" ]; then
        branch_name="develop"
    fi
fi

# check if branch exists
if git show-ref --verify --quiet refs/heads/$branch_name; then
  echo "Branch '$branch_name' exists."
else
  echo "Branch '$branch_name' does not exist."
  git fetch  --all
  exit 1
fi


# Optional backup
if [[ $backup == true ]]; then

    # create backup dir with _manifest_exclude
    mkdir -p ./__backups
    cd ./__backups
    touch _manifest_exclude

    # remove any files left from last time
    rm ssbak -f
    rm ssbak_linux_amd64.tar.gz -f
    rm LICENSE -f
    rm README.md -f
    rm ./backup.sspak -f

    # download latest
    wget -q https://github.com/axllent/ssbak/releases/latest/download/ssbak_linux_amd64.tar.gz

    # install
    tar zxvf ssbak_linux_amd64.tar.gz
    chmod +x ./ssbak

    # backup
    ./ssbak save .. ./backup.sspak

    # cleanup
    rm ssbak -f
    rm ssbak_linux_amd64.tar.gz -f
    rm LICENSE -f
    rm README.md -f

    # go back to previous dir
    cd ../
fi

# note release data in release.log
echo "=========================" >>release.log
echo "Time: $(date). START UPDATE: " >>release.log
echo "=========================" >>release.log
date >>release.log
git describe --all --long >>release.log

# get git
# Git actions with chosen branch
git checkout $branch_name
git pull origin $branch_name

# Provide a flag: dev / test / live
if [ "$SS_ENVIRONMENT_TYPE" == "dev" ]; then
    composer update --prefer-source
    composer vendor-expose
    vendor/bin/sake dev/build flush=all
elif [ "$SS_ENVIRONMENT_TYPE" == "test" ]; then
    echo "TEST environment"
elif [ "$SS_ENVIRONMENT_TYPE" == "live" ]; then
    echo "LIVE environment"
else
    echo "Invalid argument. "
    echo "... Please specify 'dev', 'test',  or 'live' "
    echo "... or make sure it is set in the env file (SS_ENVIRONMENT_TYPE)"
    exit 1
fi

# Only run the following commands if the argument is not "dev"
if [ "$SS_ENVIRONMENT_TYPE" != "dev" ]; then

    # composer update
    composer install --prefer-dist --no-dev

    # build
    vendor/bin/sake dev/build flush=all

    # vendor expose double
    composer vendor-expose

    # record new version
    git describe --all --long >>release.log

    echo "=========================" >>release.log
    echo "BRANCH: $branch_name" >>release.log
    echo "=========================" >>release.log
    echo "DONE" >>release.log
    echo "=========================" >>release.log
    echo "" >>release.log
    echo "" >>release.log

    ##########################################
    # Ping Release if FIA_RELEASE_PING_URL is set
    ##########################################

    if [ -n "$FIA_RELEASE_PING_URL" ]; then
        GIT_HASH=$(git rev-parse HEAD)
        URL_WITH_HASH="${FIA_RELEASE_PING_URL}${GIT_HASH}"
        wget -S -qO- "${URL_WITH_HASH}"
    fi

    ###############################
    # FIX FRONT-END
    ###############################
    if [ "$SS_ENVIRONMENT_TYPE" == "test" ]; then
        sed -i 's/SS_ENVIRONMENT_TYPE="test"/SS_ENVIRONMENT_TYPE="dev"/g' $FILE_PATH
    elif [ "$SS_ENVIRONMENT_TYPE" == "live" ]; then
        sed -i 's/SS_ENVIRONMENT_TYPE="live"/SS_ENVIRONMENT_TYPE="dev"/g' $FILE_PATH
    fi

    FILE_PATH="./.env"
    BASE_URL=$(grep -oP 'SS_BASE_URL="\K[^"]+' $FILE_PATH)
    # Remove any trailing slash
    BASE_URL="${BASE_URL%/}"
    NEW_URL="${BASE_URL}/dev/?flush=all"
    wget -O - $NEW_URL

    # Switch SS_ENVIRONMENT_TYPE back to its original value
    if [ "$SS_ENVIRONMENT_TYPE" == "test" ]; then
        sed -i 's/SS_ENVIRONMENT_TYPE="dev"/SS_ENVIRONMENT_TYPE="test"/g' $FILE_PATH
    elif [ "$SS_ENVIRONMENT_TYPE" == "live" ]; then
        sed -i 's/SS_ENVIRONMENT_TYPE="dev"/SS_ENVIRONMENT_TYPE="live"/g' $FILE_PATH
    fi
fi

echo ""
echo "DONE"
echo ""

rm release-running -f
